<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <style>
      * { margin: 0; padding: 0;}
      video{ position: absolute; left: 0;top: 0; width: 100%;  }
      #container{ position: absolute; left: 0; top: 0; }
    </style>
  </head>
  <body>

    <video id="video" src="media/test-footage.webm" loop></video>
    <div id="container" ></div>

    <script src="js/three.min.js"></script>
    <script src="js/loaders/collada/Animation.js"></script>
    <script src="js/loaders/collada/AnimationHandler.js"></script>
    <script src="js/loaders/collada/KeyFrameAnimation.js"></script>
    <script src="js/loaders/ColladaLoader.js"></script>

<script>

'use strict'

var videoEl = document.getElementById( 'video' );
videoEl.addEventListener( 'loadeddata', loadModel );

var container;
var scene, camera, renderer, controls;
var box;

var dae;
var animations;
var kfAnimations = [ ];
var kfAnimationsLength = 0;
var lastTimestamp = 0;
var progress = 0;
var dolly;

var loader = new THREE.ColladaLoader();
loader.options.convertUpAxis = true;

function loadModel() {

  loader.load( './models/cam-track-test10.dae', function ( collada ) {

    dae = collada.scene;
    animations = collada.animations;
    kfAnimationsLength = animations.length;
    dae.scale.x = dae.scale.y = dae.scale.z = 0.01;

    dae.getObjectByName( 'solvedCam', true ).traverse(function(child) {
      if (child instanceof THREE.PerspectiveCamera) {
          camera = child;
          camera.near = 1;
          camera.fov = 33.148;
          console.log(camera.position);
      }
    });

    camera.updateProjectionMatrix();
    camera.matrixNeedsUpdate = true;
    dae.updateMatrix();

    init();

  } );
}


function onWindowResize() {

  var w = video.clientWidth
  var h = video.clientHeight;

  camera.aspect = w / h;
  camera.updateProjectionMatrix();

  renderer.setSize( w, h );

}

// window.addEventListener( 'load', init, false );

function init() {

  container = document.getElementById( 'container' );
  renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true });
  renderer.setSize( window.innerWidth, window.innerHeight );
  container.appendChild( renderer.domElement );
  scene = new THREE.Scene();

  // camera = new THREE.PerspectiveCamera( 37.4, window.innerWidth / window.innerHeight, .000001, 1594 );
  // camera.position.set(-.0945, .5414, 2.219); // positive Y and positive Z (invert from AE);
  // camera.rotation.set(-3.089,0.00329,0.0129);
  // camera.rotation.set(0,0.00329,0.0129);
  // camera.position.set(0,.5,10);
  // scene.add( camera );
  
  box = new THREE.Mesh( new THREE.BoxGeometry( 0.4,.2,.4 ), new THREE.MeshNormalMaterial() );
  box.position.set(0,0.1,0);
  // scene.add(box);

  scene.add( dae );

  // KeyFrame Animations

  for ( var i = 0; i < kfAnimationsLength; ++i ) {

    var animation = animations[ i ];

    var kfAnimation = new THREE.KeyFrameAnimation( animation );
    kfAnimation.timeScale = 1;
    kfAnimations.push( kfAnimation );

  }

  window.addEventListener( 'resize', onWindowResize, false );

  onWindowResize();
  videoEl.play();
  start();
  animate( lastTimestamp );

}

function start() {

  for ( var i = 0; i < kfAnimationsLength; ++i ) {

    var animation = kfAnimations[i];

    for ( var h = 0, hl = animation.hierarchy.length; h < hl; h++ ) {

      var keys = animation.data.hierarchy[ h ].keys;
      var sids = animation.data.hierarchy[ h ].sids;
      var obj = animation.hierarchy[ h ];

      if ( keys.length && sids ) {

        for ( var s = 0; s < sids.length; s++ ) {

          var sid = sids[ s ];
          var next = animation.getNextKeyWith( sid, h, 0 );

          if ( next ) next.apply( sid );

        }

        obj.matrixAutoUpdate = false;
        animation.data.hierarchy[ h ].node.updateMatrix();
        obj.matrixWorldNeedsUpdate = true;

      }

    }

    animation.loop = true;
    animation.play();

  }

}

function animate( timestamp ) {

  var frameTime = ( timestamp - lastTimestamp ) * 0.001;

  if ( progress >= 0 && progress < 198 ) {

    console.log(frameTime);

    for ( var i = 0; i < kfAnimationsLength; ++i ) {

      kfAnimations[ i ].update( frameTime );

    }

  } else if ( progress >= 198 ) {

    for ( var i = 0; i < kfAnimationsLength; ++i ) {

      kfAnimations[ i ].stop();

    }

    progress = 0;
    start();

  }

  progress += frameTime;
  lastTimestamp = timestamp;
  requestAnimationFrame( animate );
  renderer.render( scene, camera );

}

// function animate(timestamp) {

//   requestAnimationFrame( animate );
//   render();

// }

// function render() {

//   var t = video.currentTime * 100;
//   renderer.render( scene, camera );
// }

</script>


</body>
</html>
